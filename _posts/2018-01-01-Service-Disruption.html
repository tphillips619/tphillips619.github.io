---
layout: post
title: "Service Disruption"
tags:
 - decision-tree
 - jupyter-notebook
 - telecom
description: Predictive modeling of cell tower service outages for a large telecom
toc: true
---
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Business-Understanding">Business Understanding<a class="anchor-link" href="#Business-Understanding">¶</a></h1><p>Being able to accurately predict the severity of cell tower faults would assist in directing limited repair/maintenance resources to remote locations and proactively mitigate tower outages that can result in network downtime, lost revenues, and breaches in regulations that govern the telecom industry.  The model should take log data from different input sources and create a prioritized list of cell towers that would direct finite maintenance resources to the most needed areas.</p>
<p>The dataset is sourced from the now completed <a href="https://www.kaggle.com/c/telstra-recruiting-network">Telstra Network Disruption</a> Kaggle competition.  This dataset is entirely categorical variables with the exception of a single discrete numerical variable.</p>
<h1 id="Data-Understanding">Data Understanding<a class="anchor-link" href="#Data-Understanding">¶</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [1]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="kn">from</span> <span class="nn">sklearn.model_selection</span> <span class="k">import</span> <span class="n">train_test_split</span><span class="p">,</span> <span class="n">GridSearchCV</span><span class="p">,</span> <span class="n">cross_val_score</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble</span> <span class="k">import</span> <span class="n">GradientBoostingClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.metrics</span> <span class="k">import</span> <span class="n">recall_score</span><span class="p">,</span> <span class="n">roc_auc_score</span><span class="p">,</span> <span class="n">roc_curve</span><span class="p">,</span> <span class="n">confusion_matrix</span>

<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="o">%</span><span class="k">matplotlib</span> inline

<span class="c1"># import seaborn as sns</span>
<span class="c1"># sns.set_style('whitegrid')</span>

<span class="n">event_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'event_type.csv'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>
<span class="n">log_feature</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'log_feature.csv'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>
<span class="n">resource_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'resource_type.csv'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>
<span class="n">severity_type</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'severity_type.csv'</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">','</span><span class="p">)</span>

<span class="n">csv_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">event_type</span><span class="p">,</span><span class="n">log_feature</span><span class="p">,</span><span class="n">resource_type</span><span class="p">,</span><span class="n">severity_type</span><span class="p">]</span>
<span class="n">df_log</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="k">lambda</span> <span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">left</span><span class="p">,</span><span class="n">right</span><span class="p">,</span><span class="n">on</span><span class="o">=</span><span class="s1">'id'</span><span class="p">),</span> <span class="n">csv_list</span><span class="p">)</span>

<span class="c1"># Remove non-numeric characters for each of the following columns</span>
<span class="n">column_list</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"event_type"</span><span class="p">,</span><span class="s2">"log_feature"</span><span class="p">,</span><span class="s2">"resource_type"</span><span class="p">,</span><span class="s2">"severity_type"</span><span class="p">]</span>
<span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">column_list</span><span class="p">:</span>
    <span class="n">df_log</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_log</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s1">'(\d+)'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    
<span class="n">df_log</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[1]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>id</th>
<th>event_type</th>
<th>log_feature</th>
<th>volume</th>
<th>resource_type</th>
<th>severity_type</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>6597</td>
<td>11</td>
<td>68</td>
<td>6</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<th>1</th>
<td>8011</td>
<td>15</td>
<td>68</td>
<td>7</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<th>2</th>
<td>2597</td>
<td>15</td>
<td>68</td>
<td>1</td>
<td>8</td>
<td>2</td>
</tr>
<tr>
<th>3</th>
<td>5022</td>
<td>15</td>
<td>172</td>
<td>2</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<th>4</th>
<td>5022</td>
<td>15</td>
<td>56</td>
<td>1</td>
<td>8</td>
<td>1</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The logs for each feature are stored in separate CSV files and should be integrated on the primary key <code>id</code>.  Once merged, id's with more than one feature present (e.g. <code>log_feature</code>) will occupy more than one row and will need to be combined in a way that does not result in data loss.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [2]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'train.csv'</span><span class="p">)</span>
<span class="n">train</span><span class="p">[</span><span class="s1">'location'</span><span class="p">]</span> <span class="o">=</span> <span class="n">train</span><span class="p">[</span><span class="s1">'location'</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s1">'(\d+)'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">test</span><span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s1">'test.csv'</span><span class="p">)</span>
<span class="n">test</span><span class="p">[</span><span class="s1">'location'</span><span class="p">]</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="s1">'location'</span><span class="p">]</span><span class="o">.</span><span class="n">str</span><span class="o">.</span><span class="n">extract</span><span class="p">(</span><span class="s1">'(\d+)'</span><span class="p">,</span> <span class="n">expand</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">all_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df_log</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> unique ids present in all logs"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_ids</span><span class="p">)))</span>

<span class="n">train_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> unique ids present in the train set"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">train_ids</span><span class="p">)))</span>

<span class="n">test_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">test</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">unique</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> unique ids present in the test set"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_ids</span><span class="p">)))</span>

<span class="n">train_idx</span> <span class="o">=</span> <span class="n">df_log</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">train_ids</span><span class="p">)</span>
<span class="n">test_idx</span> <span class="o">=</span> <span class="n">df_log</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">test_ids</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>18552 unique ids present in all logs
7381 unique ids present in the train set
11171 unique ids present in the test set
</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Features">Features<a class="anchor-link" href="#Features">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [3]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_log</span><span class="p">,</span><span class="n">train</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">'id'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">'outer'</span><span class="p">)</span>
<span class="n">df_temp</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[3]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>id</th>
<th>event_type</th>
<th>log_feature</th>
<th>volume</th>
<th>resource_type</th>
<th>severity_type</th>
<th>location</th>
<th>fault_severity</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>6597</td>
<td>11</td>
<td>68</td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<th>1</th>
<td>8011</td>
<td>15</td>
<td>68</td>
<td>7</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>0.0</td>
</tr>
<tr>
<th>2</th>
<td>2597</td>
<td>15</td>
<td>68</td>
<td>1</td>
<td>8</td>
<td>2</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<th>3</th>
<td>5022</td>
<td>15</td>
<td>172</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<th>4</th>
<td>5022</td>
<td>15</td>
<td>56</td>
<td>1</td>
<td>8</td>
<td>1</td>
<td>NaN</td>
<td>NaN</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The merged logs contain information on training and test observations. I've merged <code>location</code> from the training set and will merge the location feature from the test set here.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [4]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="c1"># test.csv contains location information that train.csv does not</span>
<span class="n">df_temp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">df_temp</span><span class="p">,</span> <span class="n">test</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="s1">'id'</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">'left'</span><span class="p">)</span>

<span class="c1"># Check that the interim merge contain the same number of rows</span>
<span class="k">if</span> <span class="p">(</span><span class="n">df_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_idx</span><span class="p">)):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"Test indicies and dataframe contain different sizes"</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> merged records"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">df_temp</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> test_idx"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">test_idx</span><span class="p">)))</span>

<span class="n">df_temp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">test_idx</span><span class="p">,</span><span class="s1">'location_x'</span><span class="p">]</span> <span class="o">=</span> <span class="n">df_temp</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">test_idx</span><span class="p">,</span><span class="s1">'location_y'</span><span class="p">]</span>
<span class="n">df_temp</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">'location_y'</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">df_temp</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s1">'location_x'</span><span class="p">:</span><span class="s1">'location'</span><span class="p">},</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">df</span> <span class="o">=</span> <span class="n">df_temp</span>

<span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[4]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>id</th>
<th>event_type</th>
<th>log_feature</th>
<th>volume</th>
<th>resource_type</th>
<th>severity_type</th>
<th>location</th>
<th>fault_severity</th>
</tr>
</thead>
<tbody>
<tr>
<th>0</th>
<td>6597</td>
<td>11</td>
<td>68</td>
<td>6</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>NaN</td>
</tr>
<tr>
<th>1</th>
<td>8011</td>
<td>15</td>
<td>68</td>
<td>7</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>0.0</td>
</tr>
<tr>
<th>2</th>
<td>2597</td>
<td>15</td>
<td>68</td>
<td>1</td>
<td>8</td>
<td>2</td>
<td>1</td>
<td>NaN</td>
</tr>
<tr>
<th>3</th>
<td>5022</td>
<td>15</td>
<td>172</td>
<td>2</td>
<td>8</td>
<td>1</td>
<td>1</td>
<td>NaN</td>
</tr>
<tr>
<th>4</th>
<td>5022</td>
<td>15</td>
<td>56</td>
<td>1</td>
<td>8</td>
<td>1</td>
<td>1</td>
<td>NaN</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I've taken the <code>location</code> feature from the test set here, because it can be useful in exploratory data analyses, but I've decided to exclude <code>location</code> as input to the modeling stage to prevent leakage from the test set.</p>
<p>Including the <code>location</code> feature was an important part of models that scored well in the competition, but perhaps not in the way the competition designers intended. There is some discussion on the forums about whether <code>location</code> was <a href="https://www.kaggle.com/c/telstra-recruiting-network/discussion/19092">truly a good feature or information leakage</a>.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Index:-'id'">Index: 'id'<a class="anchor-link" href="#Index:-'id'">¶</a></h2><p>It is tempting to use each record in the merged logs as a separate event.  Per the <a href="https://www.kaggle.com/c/telstra-recruiting-network/data">data description</a>, each <code>id</code> is a unique location-time point so records with the same <code>id</code> are concurrent events.</p>
<p>There are no timestamps that can be utilized to calculate the duration of time between records and no information about the initial state of individual components.  If these were known it would be possible to use the Mean Time Between Failure (MTBF) to calculate which components are closest to the end of their useful life. It might be possible to make inferences about the chronology of observations which is something that can be explored later.</p>
<h1 id="Data-Preparation">Data Preparation<a class="anchor-link" href="#Data-Preparation">¶</a></h1><h2 id="Dummy-Encoding-Categoricals">Dummy Encoding Categoricals<a class="anchor-link" href="#Dummy-Encoding-Categoricals">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [5]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">categoricals</span> <span class="o">=</span> <span class="p">[</span><span class="s1">'event_type'</span><span class="p">,</span><span class="s1">'log_feature'</span><span class="p">,</span> <span class="s1">'resource_type'</span><span class="p">,</span> <span class="s1">'severity_type'</span><span class="p">]</span>

<span class="n">dummies</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span><span class="n">df</span><span class="p">[</span><span class="n">categoricals</span><span class="p">])</span>

<span class="n">all_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">[[</span><span class="s1">'id'</span><span class="p">,</span><span class="s1">'fault_severity'</span><span class="p">]],</span> <span class="n">dummies</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Aggregating-by-'id'">Aggregating by 'id'<a class="anchor-link" href="#Aggregating-by-'id'">¶</a></h2><p>Events with the same <code>id</code> are concurent events and should not be treated as separate observations.  After encoding categoricals as dummy variables, I'll combine all unique <code>id</code>s into a single observation.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [6]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">all_gb</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'id'</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

<span class="n">prep1_5022</span> <span class="o">=</span> <span class="n">all_gb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">5022</span><span class="p">]</span>
<span class="n">prep1_5022</span><span class="p">[</span><span class="n">prep1_5022</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[6]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>fault_severity     NaN
event_type_11      1.0
event_type_15      1.0
log_feature_172    1.0
log_feature_193    1.0
log_feature_56     1.0
log_feature_71     1.0
resource_type_8    1.0
severity_type_1    1.0
Name: 5022, dtype: float64</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>A single <code>id</code> contains the dummy encodings for every categorical feature.  <code>volume</code> is trickier to combine into a single observation.  There were 4 different log_features present for id 5022, and they all had different values for volume.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [7]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_feature</span><span class="p">[</span><span class="n">log_feature</span><span class="p">[</span><span class="s1">'id'</span><span class="p">]</span><span class="o">==</span><span class="mi">5022</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[7]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>id</th>
<th>log_feature</th>
<th>volume</th>
</tr>
</thead>
<tbody>
<tr>
<th>3</th>
<td>5022</td>
<td>feature 172</td>
<td>2</td>
</tr>
<tr>
<th>4</th>
<td>5022</td>
<td>feature 56</td>
<td>1</td>
</tr>
<tr>
<th>5</th>
<td>5022</td>
<td>feature 193</td>
<td>4</td>
</tr>
<tr>
<th>6</th>
<td>5022</td>
<td>feature 71</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>An easy approach to aggregating the volumes for all records with the same <code>id</code> is to take the median value.  This approach treats the <code>volume</code> of all concurrent log_features as a single feature which makes it impossible to combine into a single observation without data loss.</p>
<p>Instead, I'll change each <code>log_feature</code> dummy encoding into the numerical value of its associated <code>volume</code>.  This enables aggregating all log data into a single record without data loss and makes it possible for a model to distinguish between the volumes of different log_features.  I've prepared id 5022 using both methods to illustrate both treatments.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [8]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">log_feature_gb</span> <span class="o">=</span> <span class="n">log_feature</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'id'</span><span class="p">)</span>
<span class="k">for</span> <span class="n">id_</span> <span class="ow">in</span> <span class="n">log_feature_gb</span><span class="p">:</span>
    <span class="n">single_id</span> <span class="o">=</span> <span class="n">id_</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">log_features</span> <span class="o">=</span> <span class="n">id_</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">log_features</span><span class="o">.</span><span class="n">iterrows</span><span class="p">():</span>
        <span class="n">single_log_feature</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">'log_feature'</span><span class="p">]</span>
        <span class="n">log_feature_num</span> <span class="o">=</span> <span class="n">single_log_feature</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">log_feature_string</span> <span class="o">=</span> <span class="s2">"log_feature_"</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">log_feature_num</span><span class="p">)</span>
        <span class="n">volume</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">'volume'</span><span class="p">]</span>
        <span class="n">all_gb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">single_id</span><span class="p">,</span><span class="n">log_feature_string</span><span class="p">]</span> <span class="o">=</span> <span class="n">volume</span>

<span class="n">prep2_5022</span> <span class="o">=</span> <span class="n">all_gb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="mi">5022</span><span class="p">]</span>

<span class="n">display_5022</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">({</span><span class="s1">'Method_1'</span><span class="p">:</span><span class="n">prep1_5022</span><span class="p">,</span><span class="s1">'Method_2'</span><span class="p">:</span><span class="n">prep2_5022</span><span class="p">})</span>
<span class="n">display_5022</span><span class="o">.</span><span class="n">ix</span><span class="p">[</span> <span class="n">display_5022</span><span class="p">[</span><span class="s1">'Method_1'</span><span class="p">]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[8]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>Method_1</th>
<th>Method_2</th>
</tr>
</thead>
<tbody>
<tr>
<th>fault_severity</th>
<td>NaN</td>
<td>NaN</td>
</tr>
<tr>
<th>event_type_11</th>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<th>event_type_15</th>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<th>log_feature_172</th>
<td>1.0</td>
<td>2.0</td>
</tr>
<tr>
<th>log_feature_193</th>
<td>1.0</td>
<td>4.0</td>
</tr>
<tr>
<th>log_feature_56</th>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<th>log_feature_71</th>
<td>1.0</td>
<td>3.0</td>
</tr>
<tr>
<th>resource_type_8</th>
<td>1.0</td>
<td>1.0</td>
</tr>
<tr>
<th>severity_type_1</th>
<td>1.0</td>
<td>1.0</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I plan on using gradient boosted decision trees for this dataset and the choice of handling <code>volume</code> using the 2nd method utilizes an important aspect of this class of models.  When building a node in the decision tree, the tree will explore which features to split on <em>and</em> what value to split on. The algorithm will try all possible values for volume which includes the {0,1} dummy encoding <em>and</em> all other values of <code>volume</code> that occured for it's associated <code>log_feature</code> in the training set.</p>
<p>The advantage here is that decision trees can distinguish whether the mere presence/absence of a log feature, or a specific value that measures its frequency, will be more useful in predicting tower failure.  Explained a different way, a noisey 'log_feature_193' maybe more informative that the mere presence/absence of 'log_feature_193', but a decision tree will try both when it is being fit to the training set.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Target:-'fault_severity'">Target: 'fault_severity'<a class="anchor-link" href="#Target:-'fault_severity'">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [9]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">target</span> <span class="o">=</span> <span class="s1">'fault_severity'</span>

<span class="n">ax</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">'id'</span><span class="p">)[</span><span class="s1">'fault_severity'</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">'bar'</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">'Fault Severity'</span><span class="p">)</span> 
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">'ID Count'</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"</span><span class="si">{}</span><span class="s2"> unique 'id's in the training set"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">train_idx</span><span class="p">,</span><span class="s1">'id'</span><span class="p">]</span><span class="o">.</span><span class="n">nunique</span><span class="p">()))</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>7381 unique 'id's in the training set
</pre>
</div>
</div>
<div class="output_area">
<div class="prompt"></div>
<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"/>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>There are three possible values for <code>fault_severity</code></p>
<ol>
<li>Fault 0<ul>
<li>No errors</li>
</ul>
</li>
<li>Fault 1<ul>
<li>Non-critical errors</li>
</ul>
</li>
<li>Fault 2<ul>
<li>Critical errors that result in service outage</li>
</ul>
</li>
</ol>
<p>The business case requires a model capable of predicting Fault 2 errors. I'll convert this into a binary classification problem and change all Fault 2 errors to 1, and all other observations to 0.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [10]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">all_gb</span><span class="p">[</span><span class="n">target</span><span class="p">]</span> <span class="o">=</span>  <span class="n">all_gb</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">dropna</span><span class="p">()</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span> <span class="p">:</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">x</span><span class="o">==</span><span class="mi">2</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">all_gb</span><span class="p">[</span><span class="n">target</span><span class="p">]</span><span class="o">.</span><span class="n">value_counts</span><span class="p">()</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[10]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>0.0    6655
1.0     726
Name: fault_severity, dtype: int64</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Split-Training-and-Test-Sets">Split Training and Test Sets<a class="anchor-link" href="#Split-Training-and-Test-Sets">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>I'll use an 80/20 split of labeled records to create the training set and evaluation set.  I'll tune the hyperparameters on the 80 and evaluate the results on the 20 to avoid testing the model on data it has already seen.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [11]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">train</span> <span class="o">=</span> <span class="n">all_gb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">train_ids</span><span class="p">]</span>
<span class="n">test</span> <span class="o">=</span> <span class="n">all_gb</span><span class="o">.</span><span class="n">loc</span><span class="p">[</span><span class="n">test_ids</span><span class="p">]</span>
<span class="c1"># print(train.shape) # 11,171 rows in the training set</span>
<span class="c1"># print(test.shape)  # 7381 rows in the test set</span>

<span class="n">X_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">col</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">train</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">target</span><span class="p">]]</span>

<span class="n">X_train</span><span class="p">,</span> <span class="n">X_eval</span><span class="p">,</span> <span class="n">y_train</span><span class="p">,</span> <span class="n">y_eval</span> <span class="o">=</span> <span class="n">train_test_split</span><span class="p">(</span><span class="n">train</span><span class="p">[</span><span class="n">X_cols</span><span class="p">],</span> <span class="n">train</span><span class="p">[</span><span class="n">target</span><span class="p">],</span> <span class="n">train_size</span> <span class="o">=</span> <span class="mf">0.80</span><span class="p">)</span>
<span class="n">X_test</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">X_cols</span><span class="p">]</span>
<span class="n">y_test</span> <span class="o">=</span> <span class="n">test</span><span class="p">[</span><span class="n">target</span><span class="p">]</span>
</pre></div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Data-Modeling">Data Modeling<a class="anchor-link" href="#Data-Modeling">¶</a></h1><h2 id="Scoring">Scoring<a class="anchor-link" href="#Scoring">¶</a></h2><p>Balanced scoring of False Negatives (FN) and False Positives (FP) using the <a href="https://scikit-learn.org/stable/modules/generated/sklearn.metrics.f1_score.html">F1 score</a> or <a href="https://scikit-learn.org/stable/auto_examples/model_selection/plot_precision_recall.html#compute-the-average-precision-score">Average Precision</a> would produce sub-optimal results because False Negatives are costlier than False Positives for this project.</p>
<p>I'll set the scoring objective to Recall ( TP / (TP + FN) ) to minimize the False Negatives and maximize catching all of the Fault 2 observations.  I've set small deviations from the default parameters of the GradientBoostingClassifier, but a wider range of values can be considered in the next iteration.</p>
<h2 id="Hyperparameters">Hyperparameters<a class="anchor-link" href="#Hyperparameters">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [12]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">clf</span> <span class="o">=</span> <span class="n">GradientBoostingClassifier</span><span class="p">()</span>
<span class="n">parameters</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">'max_depth'</span><span class="p">:[</span><span class="mi">3</span><span class="p">,</span><span class="mi">5</span><span class="p">],</span>
    <span class="s1">'min_samples_leaf'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span>
    <span class="s1">'n_estimators'</span><span class="p">:[</span><span class="mi">50</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">300</span><span class="p">],</span>
    <span class="s1">'subsample'</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mf">0.8</span><span class="p">]</span>
<span class="p">}</span>

<span class="n">clf_gs</span> <span class="o">=</span> <span class="n">GridSearchCV</span><span class="p">(</span><span class="n">clf</span><span class="p">,</span> <span class="n">param_grid</span><span class="o">=</span><span class="n">parameters</span><span class="p">,</span> <span class="n">scoring</span><span class="o">=</span><span class="s1">'recall'</span><span class="p">,</span> <span class="n">n_jobs</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">clf_gs</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
<span class="n">clf_gs</span><span class="o">.</span><span class="n">best_params_</span><span class="p">,</span> <span class="n">clf_gs</span><span class="o">.</span><span class="n">best_score_</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[12]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>({'max_depth': 3, 'min_samples_leaf': 2, 'n_estimators': 300, 'subsample': 1},
 0.6593418647425616)</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Evaluation">Evaluation<a class="anchor-link" href="#Evaluation">¶</a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [13]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y_pred</span> <span class="o">=</span> <span class="n">clf_gs</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">X_eval</span><span class="p">)</span>
<span class="n">y_pred_proba</span> <span class="o">=</span> <span class="n">clf_gs</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_eval</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">"Recall: </span><span class="si">{:02f}</span><span class="s2">"</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">recall_score</span><span class="p">(</span><span class="n">y_eval</span><span class="p">,</span><span class="n">y_pred</span><span class="p">)))</span>

<span class="n">conf_mat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">confusion_matrix</span><span class="p">(</span><span class="n">y_eval</span><span class="p">,</span> <span class="n">y_pred</span><span class="p">),</span>
                        <span class="n">columns</span><span class="o">=</span><span class="p">[</span><span class="s2">"Predicted Working"</span><span class="p">,</span><span class="s2">"Predicted Failure"</span><span class="p">],</span> 
                        <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s2">"Actual Working"</span><span class="p">,</span><span class="s2">"Actual Failure"</span><span class="p">])</span>
<span class="n">conf_mat</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt"></div>
<div class="output_subarea output_stream output_stdout output_text">
<pre>Recall: 0.669065
</pre>
</div>
</div>
<div class="output_area">
<div class="prompt output_prompt">Out[13]:</div>
<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped="">
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
<thead>
<tr style="text-align: right;">
<th></th>
<th>Predicted Working</th>
<th>Predicted Failure</th>
</tr>
</thead>
<tbody>
<tr>
<th>Actual Working</th>
<td>1284</td>
<td>54</td>
</tr>
<tr>
<th>Actual Failure</th>
<td>46</td>
<td>93</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>This simple model is able to accurately catch 67% of the failures in the evaluation set.</p>
<p>After obtaining a Recall score and confusion matrix from the so-far unseen evaluation set, rejoin the training and evaluation sets and refit with the best parameters from the gridsearch.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [14]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">X_train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">X_train</span><span class="p">,</span><span class="n">X_eval</span><span class="p">])</span>
<span class="n">y_train</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">y_train</span><span class="p">,</span><span class="n">y_eval</span><span class="p">])</span>

<span class="n">clf2</span> <span class="o">=</span> <span class="n">GradientBoostingClassifier</span><span class="p">(</span><span class="o">**</span><span class="n">clf_gs</span><span class="o">.</span><span class="n">best_params_</span><span class="p">)</span>
<span class="n">clf2</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X_train</span><span class="p">,</span> <span class="n">y_train</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[14]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>GradientBoostingClassifier(criterion='friedman_mse', init=None,
              learning_rate=0.1, loss='deviance', max_depth=3,
              max_features=None, max_leaf_nodes=None,
              min_impurity_decrease=0.0, min_impurity_split=None,
              min_samples_leaf=2, min_samples_split=2,
              min_weight_fraction_leaf=0.0, n_estimators=300,
              presort='auto', random_state=None, subsample=1, verbose=0,
              warm_start=False)</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Feature-Importances">Feature Importances<a class="anchor-link" href="#Feature-Importances">¶</a></h2><p>Now that model is fit onto all labeled observations, the feature importances can identify which features a network operator would want to pay closest attention to.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [15]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">num_top_features</span><span class="o">=</span><span class="mi">30</span>

<span class="n">feat_imp</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">Series</span><span class="p">(</span><span class="n">clf2</span><span class="o">.</span><span class="n">feature_importances_</span><span class="p">,</span> <span class="n">X_cols</span><span class="p">)</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">ascending</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">tail</span><span class="p">(</span><span class="n">num_top_features</span><span class="p">)</span>
<span class="c1"># feat_imp.plot(kind='barh', title='Feature Importances', figsize=(6,12))</span>
<span class="n">feat_imp</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">kind</span><span class="o">=</span><span class="s1">'barh'</span><span class="p">,</span> <span class="n">title</span><span class="o">=</span><span class="s1">'Feature Importances'</span><span class="p">,</span> <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="nb">round</span><span class="p">(</span><span class="n">num_top_features</span><span class="o">*</span><span class="mf">0.4</span><span class="p">))</span> <span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">'Feature Importance Score'</span><span class="p">)</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[15]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>Text(0,0.5,'Feature Importance Score')</pre>
</div>
</div>
<div class="output_area">
<div class="prompt"></div>
<div class="output_png output_subarea ">
<img src="data:image/png;base64,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
"/>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h2 id="Predictions">Predictions<a class="anchor-link" href="#Predictions">¶</a></h2>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The final output is the probability of Fault 2 errors for each <code>id</code> in the unlabeled test set sorted in descending order.</p>
</div>
</div>
</div>
<div class="cell border-box-sizing code_cell rendered">
<div class="input">
<div class="prompt input_prompt">In [16]:</div>
<div class="inner_cell">
<div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">y_test</span> <span class="o">=</span> <span class="n">clf2</span><span class="o">.</span><span class="n">predict_proba</span><span class="p">(</span><span class="n">X_test</span><span class="p">)</span>
<span class="n">y_test_proba</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">y_test</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">X_test</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
<span class="n">prioritized_ids</span> <span class="o">=</span> <span class="n">y_test_proba</span><span class="o">.</span><span class="n">sort_values</span><span class="p">(</span><span class="n">by</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">ascending</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="n">prioritized_ids</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
<span class="c1"># prioritized_ids.to_csv('ranked_predictions_by_id.csv')</span>
</pre></div>
</div>
</div>
</div>
<div class="output_wrapper">
<div class="output">
<div class="output_area">
<div class="prompt output_prompt">Out[16]:</div>
<div class="output_text output_subarea output_execute_result">
<pre>id
3871     0.997961
215      0.995448
563      0.991329
17691    0.988416
10354    0.986019
Name: 1, dtype: float64</pre>
</div>
</div>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="prompt input_prompt">
</div>
<div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The result is a prioritized list of towers that a maintenance team should visit first.</p>
<p>I've turned a classification problem with an anonymized feature set into a into a product that solves a problem of allocating limited resources by:</p>
<ol>
<li>Converting from a multiclass to binary classification task and targeting the label that is most relevant to the business case</li>
<li>Choosing Recall as a scoring metric and focus on catching Fault 2 errors.</li>
<li>Ranking the predictions by their probabilities and creating a prioritzed list of faulty towers.</li>
</ol>
</div>
</div>
</div>
